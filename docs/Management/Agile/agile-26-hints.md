#  26 Agile Hints

I collect nuggets of wisdom on various topics. Recently I have been going over the topic of Agile software development; what really matters?  Below is a list of 26 key principles to guide an agile software development team.

*   **Get case 1 fully working before starting case 2.** Another way of saying this to use a kitchen metaphor is: “_Serve the current meal before starting to cook the next_“. The biggest problem with software development is to start a bunch of things in parallel, because inevitably work will include something that is later discarded, meaning wasted work.  Work on one case (or a small number of cases depending upon team size); get that fully functional; get the tests running; write the documentation; check it all in as a finished piece of work, before you start on the next case.
*   **Never break the build**.  Pretty obvious, but must be included in any list of software development advice.  A programmer who is taking all the proper precautions to test before checking in will never break the build.  If the build is broken, it is always because someone took a shortcut.
*   **Never implement a routine before it is needed in a use case**.  When implementing a particular class, you should have a particular use case in mind, and you should implement only the methods required for that use case.  You might think about  the potential for other capabilities on a class, and you might document this in a comment, but implementation should wait until it is actually needed in a use case.
*   **Never add a data member before it is needed in a use case.** Exactly like above except with regard to class data members.  It may seem obvious to the programmer that a “customer” record will need a “ship to address”, but that ship to address should not be implemented until you have a use case which specifically needs it.
*   **Don’t be afraid to make a decision;  don’t be afraid to change an earlier decision**.  Agile development is about quickly responding to uncertainty.  Early in development you do not have complete information.  You should delay decisions as long as possible, but there comes a time that a decision is needed to move forward.  You can not hold up decision until that information comes in.  Instead, make the best decision you can on the available information.  Later, when new information arrives, don’t be afraid to change that decision.  (_Some dinosaurs call this flip-flopping, but I call it reacting to a changing environment._)
*   **Continually learn how to improve quality.** This job never ends, so you should expect to be constantly on the look out for things that could be improved, and collect examples of ways that quality problems were identified and addressed.
*   **Measure, measure, measure.** Agile development helps address the problem of uncertainty about the future, but there should be no uncertainty about the past.  Tests should be continually running.  Performance of every run should be measured and recorded.
*   **Design around people, not systems.** Too often developers get sidetracked into designing for technical opportunities. Never lose sight of the ultimate purpose of the software, and that is to help people get work done.
*   **Tests are part of the product**.  Many developers and managers consider the product to be what you ship to the customer, and everything else less important.  The tests should be considered an actual part of the product, worthy of full consideration during design, and even, in many cases, delivered with the product to the customer. (This latter part is controversial, but a built-in self-test as part of a software delivery takes inconsequential space, and yet provide tremendous benefit when needed.)
*   **Write the test before the code.** The test itself can be used to clarify the design for exactly what is needed.   Many times there are flaws in the design approach which are discovered when working through the test cases.  Think how much time would be saved to work through those cases before coding.  But: write the test for case1, and code for case 1, before starting case 2.
*   **Eliminate Waste.** Frankly, another ubiquitous platitude which must be included in any list of development principles because it is so important.  There is no end to the job of looking for waste where it exists and eliminating it.  Eliminate anything that does not add value to the actual customer.  If you can not identify the value to the customer, then you probably don’t need it.
*   **Build a culture of immediate response to build breakage.** Understand that when the build is broken, it effect everyone in the project, and so there is nothing more important than making sure that the central core code is building and testing properly.  I have seen teams that allowed broken tests to persist for months because is was someone else’s job.  Everyone suffered, but nobody acted.  Instead, there needs to be widespread recognition that a little work will pay back in a big way over the team.
*   **Every team members needs to understand the needs of the customer**.  Large complex projects must be broken into separate teams and further divided for handing out to developers, but this should never be done to the extent that people lose sight of the desires and goals of the actual users of the final product.
*   **Keep related definitions together.** Structure the code so that highly related things are located together, possibly within one class.   This is a standard OO design principle of encapsulation.  Ideally, all the code outside the class will not need to know the details of the internal workings.  Some developers delight in spreading details across multiple files in order to organize in different way: such as to keep all the same data types together, or to organize alphabetically.  For example, putting all the constants in one class in a different package from where they are being used adds unnecessarily to the complexity of the program.   The guiding rule should be to group by relatedness with the result being to hide complexity.
*   **Always run the tests before checking in.** This guideline will help you satisfy the  “never break the build” guideline.
*   **Premature optimization is the root of all evil.** A quote from Don Knuth which rings true today.  Code should be written well to avoid needless waste at the micro level, but optimization beyond the individual method level should wait until testing within the entire program with a stress test bases on an actual end user use case.  Intuition of what is important for overall performance is almost always wrong when based only on a static understanding of the code.  Instead, measure the behavior of the complete system, to identify the 1% of the code that really makes a different in performance, and focus on that.
*   **Minimize backlog of uncompleted coding tasks.** When a developer starts to work on a use case, there is a cost associated with all the code that has been modified, but not completed and tested.  Holding uncompleted changes for days or weeks adds up to a significant risk of waste due to rework.  Consider three tasks estimated to take 1 day each.  Starting all three at one time, and working in parallel for three days involves an accumulation of 9 “units” of cost.  But doing each task sequentially, completing each task before starting the next, involves only 3 “units” of cost.  This is not intuitive.  Our intuition tells us that while we are in there, we might as well do three things at once, before buttoning the work up.  But software is not like physical construction.  Short, quick, and complete jobs not only cause less cognitive load, but also reduce the chance that uncompleted work will conflict with another person’s uncompleted work.
*   **Never overgeneralize functionality.** This is also know as “_YAGNI – You Aren’t Going to Need It_” .  While coding a particular class, programmers like to think with a small tweak this class might be used for several other purposes.  This is fine if those purposes are required by the current use case, but usually the programmer is thinking about uses which have not been invented yet, and which may in fact never be needed.  (_This subject always reminds me of the classic Saturday Night Live skit about the product which was both a floor wax, and a dessert topping._)
*   **Never use 3 lines when 2 lines would do.** Succinctness in code pays every time someone else has to read it.  But don’t shrink the code to the point of being difficult to read.  Smaller, well written code can easier to maintain and easier to spot errors in, than verbose, ornately written code.  Always simplify as much as possible, but no more.
*   **Never ever measure code by counting lines.** The number of lines needed to do a particular task varies greatly from programmer to programmer, and from style to style.  The number of lines of code does not tell you much of anything about the completeness or the quality of the code.  Code quality can vary by a factor of 200, and this overwhelms any usefulness of the count of the lines.  Count instead functioning use cases.
*   **Continually re-design and re-factor.** Apply this cautiously because some code is brittle and difficult to change, but in general you should not be afraid to change the code to match the real use case.  A data member may have been an integer in the past, but when a use case requires it to be a floating point don’t be afraid to change it, only be sure to complete everything: tests, documentation, installer.
*   **Delete dead code.** There is a tendency to let “sleeping dogs lie” when it comes to large blocks of code that is not well understood.  One example is adding a new method to a class to replace another, quite often the developer will leave the old method there “just in case”.  Some effort should be expended to check to see if that method is needed, and _delete it_ if there is no evidence that it is needed.  The worst offense is commenting out blocks of code, and leaving that commented code around.  Commented code should be deleted as soon as you know that the tests run, and certainly before checking it in.  It is easy to add code at any time, it is hard to delete code at any time.  Therefor, at a particular time that you have a good idea that something might not be needed, and small extra effort to verify this and eliminate the code will make the codebase more maintainable.
*   **Don’t invent new languages.** Programmers love to make text files that drive functionality in way configurable at run-time.  There are no end of configuration files to be able to change the behavior of the program without recompiling.  The advent of XML is driving a chain of specialized custom “scripting languages” that allow functionality to be “programmed” by the end user without having to compile.   The flaw in this reasoning is that the precise definition of the behavior of the operations almost never well defined outside of the context of a particular implementation, and these types of scripting languages are mainly useful only to people who have an intimate knowledge of the internal working of the code body in question.  Thus, real end users without detailed internal knowledge can never possibly know what is necessary to anticipate the effect of complex combinations of commands.   Scripting languages have a use, and can not be eliminated, but the designer must take a very very conservative approach and use existing languages as far as possible, and avoid inventing new ones.
*   **Do not create a design until you are ready to implement and test the implementation.** You should have some overall idea of where you are going, and a overview of the system architecture that will be aimed for, but no detailed design, no detailed description of functional implementation should be written down until the development iteration that will allow that design to be implemented and tests.  The detailed design should cover only as much as is needed to handle the current use case.  The biggest cause of waste in software development is time spend designing things that are not needed or need to be redesigned because of some mistaken assumptions that the design is based on.
*   **Software is Plastic.** Unlike physical manufacturing, software can be changed in significant ways very easily.   In fact there is plenty of evidence that software is easier to change than the design specifications that describe the software.  Furthermore, software communicates the design more effectively than the specification.  Therefor, you should spend the time to implement the design directly, so that customers can see the details of the design.  If you miss and have the change the design, it is easier to change the software than it would be to change the spec.   But most important, your information about what the customers wants is far better after they have seen the code running.
*   **Take the time to code a complete description of the problem in the code that detects and reports exceptional situations.** Programmers are often very lazy and throw exceptions with superficial descriptions of what is wrong.  Thinking that they are the only people who will ever see the problem, and they will remember the meaning of the problem from the vague description included.  But in fact more time is wasted in customer support situations because of inaccurate or incomplete error reports than any other cause.   Write every error message is if you are explaining the situation to someone who just walked into the room and has no experience with the code.  The customer, and the customer support team, after all, have no experience with the code.

These are presented in no particular order.  I welcome comments on principles that I have left out, or (if this is the case) principles that you disagree with.

This entry was posted in [practice](https://agiletribe.purplehillsbooks.com/category/practice/) and tagged [agile](https://agiletribe.purplehillsbooks.com/tag/agile/), [methodology](https://agiletribe.purplehillsbooks.com/tag/methodology/). Bookmark the [permalink](https://agiletribe.purplehillsbooks.com/2013/02/22/26-hints-for-agile-software-development/ "Permalink to 26 Hints for Agile Software Development").